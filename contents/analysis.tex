\chapter{{\TeX}の字句解析超入門} \label{sec:seq}

マクロの具体的な作り方の前に，まずは{\TeX}の字句解析についてざっくりと復習しておこう．
なお，ここではざっくりとした感覚をつかむことを目的としているため，正確性はまるで意識していない．
そのため，この節の内容は{\TeX}処理系や{\TeX}言語の入門としてはまったく役に立たないということに注意しよう．
むしろ，「この後の説明のどこが破綻しているか」を考えることがよい勉強になる可能性すらある．

\section{プリミティブとマクロ} \label{sec:primitive}

{\TeX}において，何らかの動作を実行する命令は%
\term{プリミティブ}%
\index[widx]{プリミティブ@プリミティブ}%
と%
\term{マクロ}%
\index[widx]{マクロ@マクロ}%
に大別される．

プリミティブなのは{\TeX}で定義されている命令の一部であるから，
普段我々が目にしている命令のほとんどはマクロであるということになる．
これから我々が行うのも，単に「複数の命令にわかりやすい名前を付けよう」というだけにすぎない．
しかしそのためには，まず「{\TeX}が命令をどのように認識しているか」を知らなければならない．

\section{カテゴリーコードとトークン} \label{sec:categorycode}

{\TeX}では，ソース中の文字に対して%
\Cref{tab:chap::simplemacro_sec::analysis_subsec::token_category}に示す0から15までの
\index[widx]{カテゴリーコード@カテゴリーコード}%
\term{カテゴリーコード}という整数値が割り当てられている．

和文のことを無視すれば，ソース中の文字とカテゴリーコードとの対応は以下のようになっている．

\begin{table}[htbp]
	\centering
	\caption{{\TeX}におけるカテゴリーコードとその役割，および通常各カテゴリーコードに属する文字，
		ここでは和文文字は一切考慮していない．}
	\label{tab:chap::simplemacro_sec::analysis_subsec::token_category}
	\begin{tabular}{ccc}
		\toprule
		カテゴリーコード & 分類                 & 属する文字                                  \\ \midrule
		0                & 制御綴の開始         & 「\cs{}」                                   \\
		1                & グルーピング（開始） & 「\cmd{\textbraceleft}」                    \\
		2                & グルーピング（終了） & 「\cmd{\textbraceright} 」                  \\
		3                & 数式の区切り         & 「\cmd{\textbraceright}」                   \\
		4                & アライメントタブ     & 「\lstinline|&|」                  \\
		5                & 行末                 & 「\lstinline|^^M|」（文字コード13）  \\
		6                & パラメータ文字       & 「\lstinline|#|」                  \\
		7                & 上付き文字（数式中） & 「\lstinline|^|」                  \\
		8                & 下付き文字（数式中） & 「\lstinline|_|」                  \\
		9                & 無視される文字       & 「\lstinline|^^@|」（文字コード0）   \\
		10               & 空白文字             & 「\cmd{\textvisiblespace}」（文字コード32） \\
		11               & 英字                 & 英語アルファベット                          \\
		12               & 記号                 & 数字と「\cmd{!}」，「\cmd{?}」他多数        \\
		13               & アクティブ文字       & 「\lstinline|~|」                  \\
		14               & コメント開始         & 「\lstinline|%|」                  \\
		15               & 無効文字             & 「\lstinline|^^?|」（文字コード127） \\
		\bottomrule
	\end{tabular}
\end{table}

\Cref{tab:chap::simplemacro_sec::analysis_subsec::token_category}には「\lstinline|^^|」から始まる奇妙な文字もあるが，
ひとまず気にする必要はない．また，カテゴリーコード10の「\cmd{\textvisiblespace}」は単なるスペースであると考えてよい．

基本的に，カテゴリーコード11と12以外の文字はソース中で特別な役割を果たす文字であり，そのまま打ち込んでも表示されない．

{\TeX}は，ソースとして受け取ったテキストファイルを%
\index[widx]{トークン@トークン}%
\term{トークン}と呼ばれる塊に分解し，それをもとに動作する．
何を1つのトークンとみなすかは，おおむね次のような規則に従っていると考えることができる：
\begin{enumerate}
	\item カテゴリコード0の文字の直後にカテゴリーコード11の文字がある場合，
	      そこから続くすべてのカテゴリーコード11の文字をまとめて1つのトークンとみなす．
	\item このとき，そのトークン直後のカテゴリーコード10の文字は（いくつ続いても）無視される．
	\item カテゴリーコード0の文字の直後にカテゴリーコード11以外の文字がある場合，その文字までを1つのトークンとみなす．
	\item それ以外の場合，その文字1つを単独のトークンとみなす．
\end{enumerate}

\begin{Ex} \label{Ex:chap:simplemacro_sec::analysis_subsec::token_token}
	ソース中にある．「\cmd{\cs{LaTeX}3\textvisiblespace is\textvisiblespace good.}」という
	文字列を考える（「\cmd{\textvisiblespace}」は空白を表す）．
	最初にカテゴリーコード0の「\cs{}」が存在していることから，そこから続く「\lstinline|\LaTeX|」までが1つのトークンとみなされる．
	そしてその直後に続くトークンは「\lstinline|3|」である．
	さらに続く英字や空白は1文字につき1つのトークンとみなされる．
	最後のトークンは「\cmd{.}」である．
	すなわち，上の文字列は「\cs{LaTeX}」「\lstinline|3|」「\cmd{\textvisiblespace}」
	「\cmd{i}」…「\cmd{d}」「\cmd{.}」という11個のトークンに分解される．
\end{Ex}

トークンのうち，カテゴリーコード0の文字（すなわちバックスラッシュ「\cs{}」）から始まるものを%
\term{制御綴}%
\index[widx]{制御綴}%
と呼ぶ．
{\LaTeX}においては，何らかの動作を行うことが期待される命令を%
\term{コマンド}%
\index[widx]{コマンド@コマンド}%
と呼ぶ．コマンドの中で主要なのは，まさにこの制御綴である．

ところで，これまで述べてきたことからもわかるように，
カテゴリーコード0の文字から続くカテゴリーコード11の文字は，まとめて1つのトークン，特に制御綴とみなされる．
このことからわかるのは，\emph{制御綴の名前に使えるのはアルファベットの大文字・小文字のみである}ということである%
\footnote{%
	和文対応環境では，和文文字も制御綴の名前に使えることがある．よく使う例として\cs{today}コマンドの書式を変更する%
	\index[cidx]{西暦@\cs{西暦}}%
	\cs{西暦}コマンドと%
	\index[cidx]{和暦@\cs{和暦}}%
	\cs{和暦}コマンドが挙げられる．%
}%
．
しかし，「\cs{\#}」や「\cs{\$}」のような制御綴の存在を考えると，このルールはおかしく見える．
このような制御綴が存在しているのは，カテゴリーコード12の文字1つだけの場合は例外的に制御綴の名前に使えるということにしているからである．
従って，「\lstinline|I watch TV\@.|」中のトークン「\lstinline|\@|」は制御綴とみなされる．
そして，その直後に空白があれば，それは無視されるわけではなく空白文字トークンとして認識されるのである．

各文字に割り当てられたカテゴリーコードは変更することができるが，
エンドユーザーとしてはあまり行うべきではないということはいうまでもないだろう．
しかし，カテゴリーコード12の文字「\lstinline|@|」だけはカテゴリーコード11に変更することがよくある．
そのためのコマンドとして，%
\index[cidx]{makeatletter@\cs{makeatletter}}%
\cs{makeatletter}コマンドと%
\index[cidx]{makeatother@\cs{makeatother}}%
\cs{makeatother}コマンドが用意されている．
\cs{makeatletter}コマンドを記述した場所以降では「\cmd{@}」がカテゴリーコード11に変更され制御綴の名前に使えるようになり，
\cs{makeatother}コマンドを記述した場所以降では「\cmd{@}」がカテゴリーコード12に戻る．
この仕組みは，ユーザー側に触れてほしくない内部でのみ使われるコマンドを定義するのに役に立つ．

\section{引数の処理} \label{subsec:chap::simplemacro_sec::analysis_argument}

{\TeX}で扱う制御綴には，引数をともなうものとそうでないものがあった．
そして，どこからどこまでが引数であるかはグルーピングを表す文字「\cmd{\textbraceleft}」と「\cmd{\textbraceright}」
で指定するのであった．

引数が複数のトークンからなる場合，グルーピングによってその範囲を指定しなければならない．
一方で，引数がただ1つのトークンからなる場合，グルーピングによる範囲指定は省略できる
（グループ指定を省略した場合，直後のトークンが引数とみなされる）．

\begin{Ex} \label{Ex:chap::simplemacro_sec::analysis_subsec::argument_argument}
	それぞれの書き方で何が\cs{textbf}コマンドの引数とみなされているかに注意しよう．
	\cs{textbf}コマンドは引数を1つとる制御綴であった．
    \inputonly{samplecode/argument}  
    出力は，上から順に「\textbf\LaTeX」「\textbf LaTeX」「\textbf{LaTeX}」となる．
\end{Ex}

マクロを作成していて奇妙な挙動が見られた場合，引数指定が適切であるかどうかも考えておく必要があるだろう．


\section{展開と実行} \label{subsec:chap::simplemacro_sec::analysis_expand}

トークンには，処理された結果別のトークン列に変換されるものがある．
この変換処理を%
\index[widx]{てんかい@展開}%
\term{展開}という．展開できるトークンは%
\index[widx]{てんかい@展開!てんかいかのう@---可能}%
\term{展開可能}であるという．
あるトークンの展開結果として現れたトークンは，展開可能であれば再び展開される．
そして，展開可能でないトークンになるまで展開操作は続く．
展開可能でないトークンが現れた場合，そのトークンによって定められた何らかの処理が行われることになる．
これを%
\index[widx]{じっこう@実行}%
\term{実行}という．

当然のことながら，制御綴のうちで展開可能でないものはプリミティブに限る
（が，プリミティブでも展開可能であるものは存在する）．
我々が文書作成でよく使う制御綴はほとんどすべて展開可能である．

以上の事項を念頭に置きながら，マクロの作成方法について学んでいく．